import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Checkbox } from '@/components/ui/checkbox';
import { 
  GitBranch,
  Link2,
  Unlink,
  AlertCircle,
  CheckCircle2,
  Info,
  ArrowRight,
  Circle,
  Star,
  Shuffle
} from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';

export default function DependencyBuilder({ template, onUpdate }) {
  const [stages, setStages] = useState(template.stages || []);
  const [selectedStage, setSelectedStage] = useState(null);
  const [dependencies, setDependencies] = useState({});
  const [validationErrors, setValidationErrors] = useState([]);
  const { toast } = useToast();

  // Initialize dependencies from template stages
  useEffect(() => {
    const deps = {};
    stages.forEach(stage => {
      deps[stage.id] = stage.dependencies || [];
    });
    setDependencies(deps);
  }, [template]);

  // Validate dependencies for circular references
  const validateDependencies = () => {
    const errors = [];
    
    // Check for circular dependencies using DFS
    const checkCircular = (stageId, visited = new Set(), path = []) => {
      if (visited.has(stageId)) {
        const cycle = [...path, stageId];
        errors.push({
          type: 'circular',
          message: `Circular dependency detected: ${cycle.map(id => 
            stages.find(s => s.id === id)?.name || id
          ).join(' â†’ ')}`
        });
        return true;
      }

      visited.add(stageId);
      path.push(stageId);

      const stageDeps = dependencies[stageId] || [];
      for (const depId of stageDeps) {
        if (checkCircular(depId, new Set(visited), [...path])) {
          return true;
        }
      }

      return false;
    };

    // Check each stage for circular dependencies
    stages.forEach(stage => {
      checkCircular(stage.id);
    });

    // Check for missing dependencies
    Object.entries(dependencies).forEach(([stageId, deps]) => {
      deps.forEach(depId => {
        if (!stages.find(s => s.id === depId)) {
          errors.push({
            type: 'missing',
            message: `Stage "${stages.find(s => s.id === stageId)?.name}" has dependency on non-existent stage`
          });
        }
      });
    });

    setValidationErrors(errors);
    return errors.length === 0;
  };

  // Add dependency
  const addDependency = (stageId, dependencyId) => {
    if (stageId === dependencyId) {
      toast({
        title: "Invalid dependency",
        description: "A stage cannot depend on itself.",
        variant: "destructive"
      });
      return;
    }

    const newDeps = {
      ...dependencies,
      [stageId]: [...(dependencies[stageId] || []), dependencyId]
    };
    
    setDependencies(newDeps);
    
    // Update template
    const updatedStages = stages.map(s => 
      s.id === stageId 
        ? { ...s, dependencies: newDeps[stageId] }
        : s
    );
    
    onUpdate({ stages: updatedStages });

    // Validate after adding
    setTimeout(() => validateDependencies(), 100);
  };

  // Remove dependency
  const removeDependency = (stageId, dependencyId) => {
    const newDeps = {
      ...dependencies,
      [stageId]: (dependencies[stageId] || []).filter(d => d !== dependencyId)
    };
    
    setDependencies(newDeps);
    
    // Update template
    const updatedStages = stages.map(s => 
      s.id === stageId 
        ? { ...s, dependencies: newDeps[stageId] }
        : s
    );
    
    onUpdate({ stages: updatedStages });

    // Validate after removing
    setTimeout(() => validateDependencies(), 100);
  };

  // Auto-generate dependencies based on phase order
  const autoGenerateDependencies = () => {
    const phaseOrder = [
      'Onboarding',
      'Research',
      'Strategy',
      'Brand Building',
      'Brand Collaterals',
      'Brand Activation'
    ];

    const newDeps = {};
    
    stages.forEach((stage, index) => {
      newDeps[stage.id] = [];
      
      // Add dependency on previous stage in same phase
      if (index > 0) {
        const prevStage = stages[index - 1];
        if (prevStage.phase === stage.phase) {
          newDeps[stage.id].push(prevStage.id);
        }
      }
      
      // Add dependency on last stage of previous phase
      const currentPhaseIndex = phaseOrder.indexOf(stage.phase);
      if (currentPhaseIndex > 0) {
        const previousPhase = phaseOrder[currentPhaseIndex - 1];
        const previousPhaseStages = stages.filter(s => s.phase === previousPhase);
        if (previousPhaseStages.length > 0) {
          const lastStageOfPrevPhase = previousPhaseStages[previousPhaseStages.length - 1];
          if (!newDeps[stage.id].includes(lastStageOfPrevPhase.id)) {
            newDeps[stage.id].push(lastStageOfPrevPhase.id);
          }
        }
      }
    });

    setDependencies(newDeps);
    
    // Update template
    const updatedStages = stages.map(s => ({
      ...s,
      dependencies: newDeps[s.id]
    }));
    
    onUpdate({ stages: updatedStages });

    toast({
      title: "Dependencies generated",
      description: "Automatic dependencies have been created based on phase order."
    });

    // Validate after generation
    setTimeout(() => validateDependencies(), 100);
  };

  // Clear all dependencies
  const clearAllDependencies = () => {
    const newDeps = {};
    stages.forEach(stage => {
      newDeps[stage.id] = [];
    });
    
    setDependencies(newDeps);
    
    // Update template
    const updatedStages = stages.map(s => ({
      ...s,
      dependencies: []
    }));
    
    onUpdate({ stages: updatedStages });

    toast({
      title: "Dependencies cleared",
      description: "All dependencies have been removed."
    });
  };

  // Get stage by ID
  const getStage = (id) => stages.find(s => s.id === id);

  // Get dependent stages (stages that depend on the given stage)
  const getDependentStages = (stageId) => {
    return stages.filter(s => (dependencies[s.id] || []).includes(stageId));
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-semibold">Dependency Builder</h3>
          <p className="text-sm text-gray-600">
            Configure dependencies between stages to define workflow order
          </p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={clearAllDependencies}>
            <Unlink className="w-4 h-4 mr-2" />
            Clear All
          </Button>
          <Button onClick={autoGenerateDependencies}>
            <Shuffle className="w-4 h-4 mr-2" />
            Auto-Generate
          </Button>
        </div>
      </div>

      {/* Validation Errors */}
      {validationErrors.length > 0 && (
        <Alert className="border-red-200 bg-red-50">
          <AlertCircle className="h-4 w-4 text-red-600" />
          <AlertDescription className="text-red-700">
            <div className="font-medium mb-1">Dependency Issues:</div>
            <ul className="list-disc list-inside space-y-1">
              {validationErrors.map((error, i) => (
                <li key={i} className="text-sm">{error.message}</li>
              ))}
            </ul>
          </AlertDescription>
        </Alert>
      )}

      {/* Instructions */}
      <Alert>
        <Info className="h-4 w-4" />
        <AlertDescription>
          Select a stage to configure its dependencies. Dependencies define which stages must be completed before a stage can begin.
        </AlertDescription>
      </Alert>

      {/* Main Content */}
      <div className="grid grid-cols-2 gap-6">
        {/* Stage List */}
        <Card>
          <CardHeader>
            <CardTitle className="text-base">Stages</CardTitle>
            <CardDescription>
              Click a stage to configure its dependencies
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-2 max-h-[600px] overflow-y-auto">
            {stages.map(stage => {
              const stageDeps = dependencies[stage.id] || [];
              const dependents = getDependentStages(stage.id);
              
              return (
                <div
                  key={stage.id}
                  onClick={() => setSelectedStage(stage)}
                  className={`
                    p-3 border rounded-lg cursor-pointer transition-colors
                    ${selectedStage?.id === stage.id 
                      ? 'border-blue-500 bg-blue-50' 
                      : 'hover:bg-gray-50'
                    }
                  `}
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      {stage.is_deliverable ? (
                        <Star className="w-4 h-4 text-yellow-500" />
                      ) : (
                        <Circle className="w-4 h-4 text-gray-400" />
                      )}
                      <span className="font-medium text-sm">
                        {stage.order_index}. {stage.name}
                      </span>
                    </div>
                    <div className="flex items-center gap-2">
                      {stageDeps.length > 0 && (
                        <Badge variant="secondary" className="text-xs">
                          {stageDeps.length} deps
                        </Badge>
                      )}
                      {dependents.length > 0 && (
                        <Badge variant="outline" className="text-xs">
                          {dependents.length} dependents
                        </Badge>
                      )}
                    </div>
                  </div>
                  <div className="text-xs text-gray-500 mt-1">
                    {stage.phase}
                  </div>
                </div>
              );
            })}
          </CardContent>
        </Card>

        {/* Dependency Configuration */}
        <Card>
          <CardHeader>
            <CardTitle className="text-base">
              {selectedStage ? `Dependencies for: ${selectedStage.name}` : 'Select a Stage'}
            </CardTitle>
            <CardDescription>
              {selectedStage 
                ? 'Check stages that must be completed before this stage can begin'
                : 'Click a stage on the left to configure its dependencies'
              }
            </CardDescription>
          </CardHeader>
          <CardContent>
            {selectedStage ? (
              <div className="space-y-4">
                {/* Current Dependencies */}
                <div className="space-y-2">
                  <div className="text-sm font-medium text-gray-700">
                    Current Dependencies ({(dependencies[selectedStage.id] || []).length})
                  </div>
                  {(dependencies[selectedStage.id] || []).length > 0 ? (
                    <div className="space-y-2">
                      {(dependencies[selectedStage.id] || []).map(depId => {
                        const depStage = getStage(depId);
                        if (!depStage) return null;
                        
                        return (
                          <div
                            key={depId}
                            className="flex items-center justify-between p-2 bg-blue-50 border border-blue-200 rounded"
                          >
                            <div className="flex items-center gap-2">
                              <ArrowRight className="w-4 h-4 text-blue-500" />
                              <span className="text-sm">
                                {depStage.order_index}. {depStage.name}
                              </span>
                              <Badge variant="secondary" className="text-xs">
                                {depStage.phase}
                              </Badge>
                            </div>
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => removeDependency(selectedStage.id, depId)}
                            >
                              <Unlink className="w-3 h-3" />
                            </Button>
                          </div>
                        );
                      })}
                    </div>
                  ) : (
                    <div className="text-sm text-gray-500 italic">
                      No dependencies configured
                    </div>
                  )}
                </div>

                {/* Available Dependencies */}
                <div className="space-y-2">
                  <div className="text-sm font-medium text-gray-700">
                    Available Dependencies
                  </div>
                  <div className="max-h-[300px] overflow-y-auto space-y-1 border rounded-lg p-2">
                    {stages
                      .filter(s => 
                        s.id !== selectedStage.id && 
                        !((dependencies[selectedStage.id] || []).includes(s.id))
                      )
                      .map(stage => (
                        <div
                          key={stage.id}
                          className="flex items-center justify-between p-2 hover:bg-gray-50 rounded"
                        >
                          <div className="flex items-center gap-2">
                            <Checkbox
                              checked={false}
                              onCheckedChange={() => 
                                addDependency(selectedStage.id, stage.id)
                              }
                            />
                            <label className="text-sm cursor-pointer">
                              {stage.order_index}. {stage.name}
                            </label>
                            <Badge variant="outline" className="text-xs">
                              {stage.phase}
                            </Badge>
                          </div>
                        </div>
                      ))}
                  </div>
                </div>

                {/* Dependent Stages */}
                <div className="space-y-2">
                  <div className="text-sm font-medium text-gray-700">
                    Stages Depending on This ({getDependentStages(selectedStage.id).length})
                  </div>
                  {getDependentStages(selectedStage.id).length > 0 ? (
                    <div className="space-y-1">
                      {getDependentStages(selectedStage.id).map(stage => (
                        <div
                          key={stage.id}
                          className="p-2 bg-orange-50 border border-orange-200 rounded text-sm"
                        >
                          {stage.order_index}. {stage.name}
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-sm text-gray-500 italic">
                      No stages depend on this stage
                    </div>
                  )}
                </div>
              </div>
            ) : (
              <div className="text-center py-12 text-gray-500">
                <GitBranch className="w-12 h-12 mx-auto mb-3 text-gray-300" />
                <p>Select a stage to configure dependencies</p>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      {/* Summary */}
      <Card>
        <CardContent className="pt-6">
          <div className="grid grid-cols-3 gap-4 text-center">
            <div>
              <div className="text-2xl font-bold">
                {Object.values(dependencies).reduce((sum, deps) => sum + deps.length, 0)}
              </div>
              <div className="text-sm text-gray-600">Total Dependencies</div>
            </div>
            <div>
              <div className="text-2xl font-bold">
                {stages.filter(s => (dependencies[s.id] || []).length === 0).length}
              </div>
              <div className="text-sm text-gray-600">Independent Stages</div>
            </div>
            <div>
              <div className="text-2xl font-bold text-green-600">
                {validationErrors.length === 0 ? (
                  <CheckCircle2 className="w-8 h-8 mx-auto" />
                ) : (
                  <span className="text-red-600">{validationErrors.length}</span>
                )}
              </div>
              <div className="text-sm text-gray-600">
                {validationErrors.length === 0 ? 'Valid' : 'Issues Found'}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}